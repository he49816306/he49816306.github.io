{"meta":{"title":"Malroy的博客","subtitle":"会当凌绝顶","description":"重庆科技大学 | 计算机科学与技术 | 自然语言处理","author":"Malroy","url":"http://he49816306.github.io","root":"/"},"pages":[{"title":"404","date":"2019-07-19T08:41:10.000Z","updated":"2020-06-17T09:38:04.362Z","comments":true,"path":"404.html","permalink":"http://he49816306.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-07-19T08:41:10.000Z","updated":"2021-01-07T06:12:11.968Z","comments":true,"path":"about/index.html","permalink":"http://he49816306.github.io/about/index.html","excerpt":"","text":"教育经历 硕士 计算机科学与技术重庆大学2019/06 - 现在 本科 计算机科学与技术 | 软件工程重庆科技大学2014/09 - 2019/06综合排名专业第一 获得荣誉2019 优秀毕业生优秀毕业生（重庆） 一等奖学金奖学金（校级） 企业荣誉项目组特别突出员工 2018 一等奖学金奖学金（校级） 团体一等奖中国高校计算机大赛-团体程序设计天梯赛 高校一等奖中国高校计算机大赛-团体程序设计天梯赛 2017 荣誉证书科技创新优秀学生（校级） 荣誉证书自立自强优秀学生（校级） 铜牌大学生微信小程序大赛（第一届） 一等奖学金奖学金（校级） 2016 国家奖学金奖学金（国家级） 铜牌大学生数学建模大赛（重庆） 联系方式 电子邮箱62614929@qq.com 地址重庆市沙坪坝 QQ 技术交流群520520520"},{"title":"archives","date":"2019-07-19T08:39:20.000Z","updated":"2020-06-17T09:38:04.364Z","comments":true,"path":"archives/index.html","permalink":"http://he49816306.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-19T08:39:20.000Z","updated":"2020-06-17T09:38:04.365Z","comments":true,"path":"categories/index.html","permalink":"http://he49816306.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2019-07-26T09:17:02.000Z","updated":"2020-06-18T09:16:51.437Z","comments":true,"path":"contact/index.html","permalink":"http://he49816306.github.io/contact/index.html","excerpt":"","text":"欢迎留言大家有任何问题，都可以在评论区给我留言，或者加 QQ 技术交流群【群号：520520520】。 我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。 友链交换想要交换友链的小伙伴，欢迎在评论区留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2020-06-17T09:38:04.366Z","comments":true,"path":"tags/index.html","permalink":"http://he49816306.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-19T08:42:10.000Z","updated":"2020-06-18T09:17:06.050Z","comments":true,"path":"friends/index.html","permalink":"http://he49816306.github.io/friends/index.html","excerpt":"","text":"友链交换想要交换友链的小伙伴，欢迎在留言板留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址"}],"posts":[{"title":"Redis分布式锁","slug":"Redis分布式锁","date":"2021-01-04T06:21:47.000Z","updated":"2021-01-07T06:22:56.169Z","comments":true,"path":"2021/01/04/Redis分布式锁/","link":"","permalink":"http://he49816306.github.io/2021/01/04/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","excerpt":"","text":"一、业务背景有些业务请求，属于耗时操作，需要加锁，防止后续的并发操作，同时对数据库的数据进行操作，需要避免对之前的业务造成影响。 二、分析流程使用 Redis 作为分布式锁，将锁的状态放到 Redis 统一维护，解决集群中单机 JVM 信息不互通的问题，规定操作顺序，保护用户的数据正确。 梳理设计流程 新建注解 @interface，在注解里设定入参标志 增加 AOP 切点，扫描特定注解 建立 @Aspect 切面任务，注册 bean 和拦截特定方法 特定方法参数 ProceedingJoinPoint，对方法 pjp.proceed() 前后进行拦截 切点前进行加锁，任务执行后进行删除 key 核心步骤：加锁、解锁和续时 加锁使用了 RedisTemplate 的 opsForValue.setIfAbsent 方法，判断是否有 key，设定一个随机数 UUID.random().toString，生成一个随机数作为 value。 从 redis 中获取锁之后，对 key 设定 expire 失效时间，到期后自动释放锁。 按照这种设计，只有第一个成功设定 Key 的请求，才能进行后续的数据操作，后续其它请求由于无法获得🔐资源，将会失败结束。 超时问题担心 pjp.proceed() 切点执行的方法太耗时，导致 Redis 中的 key 由于超时提前释放了。 例如，线程 A 先获取锁，proceed 方法耗时，超过了锁超时时间，到期释放了锁，这时另一个线程 B 成功获取 Redis 锁，两个线程同时对同一批数据进行操作，导致数据不准确。 解决方案：增加一个「续时」任务不完成，锁不释放： 维护了一个定时线程池 ScheduledExecutorService，每隔 2s 去扫描加入队列中的 Task，判断是否失效时间是否快到了，公式为：【失效时间】&lt;= 【当前时间】+【失效间隔（三分之一超时）】 /** * 线程池，每个 JVM 使用一个线程去维护 keyAliveTime，定时执行 runnable */ private static final ScheduledExecutorService SCHEDULER = new ScheduledThreadPoolExecutor(1, new BasicThreadFactory.Builder().namingPattern(&quot;redisLock-schedule-pool&quot;).daemon(true).build()); static { SCHEDULER.scheduleAtFixedRate(() -&gt; { // do something to extend time }, 0, 2, TimeUnit.SECONDS); } 三、设计方案经过上面的分析，小何设计出了这个方案： 前面已经说了整体流程，这里强调一下几个核心步骤： 拦截注解 @RedisLock，获取必要的参数 加锁操作 续时操作 结束业务，释放锁 四、实操之前也有整理过 AOP 使用方法，可以参考一下 相关属性类配置业务属性枚举设定public enum RedisLockTypeEnum { /** * 自定义 key 前缀 */ ONE(&quot;Business1&quot;, &quot;Test1&quot;), TWO(&quot;Business2&quot;, &quot;Test2&quot;); private String code; private String desc; RedisLockTypeEnum(String code, String desc) { this.code = code; this.desc = desc; } public String getCode() { return code; } public String getDesc() { return desc; } public String getUniqueKey(String key) { return String.format(&quot;%s:%s&quot;, this.getCode(), key); } }任务队列保存参数 public class RedisLockDefinitionHolder { /** * 业务唯一 key */ private String businessKey; /** * 加锁时间 (秒 s) */ private Long lockTime; /** * 上次更新时间（ms） */ private Long lastModifyTime; /** * 保存当前线程 */ private Thread currentTread; /** * 总共尝试次数 */ private int tryCount; /** * 当前尝试次数 */ private int currentCount; /** * 更新的时间周期（毫秒）,公式 = 加锁时间（转成毫秒） / 3 */ private Long modifyPeriod; public RedisLockDefinitionHolder(String businessKey, Long lockTime, Long lastModifyTime, Thread currentTread, int tryCount) { this.businessKey = businessKey; this.lockTime = lockTime; this.lastModifyTime = lastModifyTime; this.currentTread = currentTread; this.tryCount = tryCount; this.modifyPeriod = lockTime * 1000 / 3; } }设定被拦截的注解名字@Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD, ElementType.TYPE}) public @interface RedisLockAnnotation { /** * 特定参数识别，默认取第 0 个下标 */ int lockFiled() default 0; /** * 超时重试次数 */ int tryCount() default 3; /** * 自定义加锁类型 */ RedisLockTypeEnum typeEnum(); /** * 释放时间，秒 s 单位 */ long lockTime() default 30; }核心切面拦截的操作RedisLockAspect.java 该类分成三部分来描述具体作用 Pointcut 设定/** * @annotation 中的路径表示拦截特定注解 */ @Pointcut(&quot;@annotation(cn.sevenyuan.demo.aop.lock.RedisLockAnnotation)&quot;) public void redisLockPC() { }Around 前后进行加锁和释放锁前面步骤定义了我们想要拦截的切点，下一步就是在切点前后做一些自定义操作： @Around(value = &quot;redisLockPC()&quot;) public Object around(ProceedingJoinPoint pjp) throws Throwable { // 解析参数 Method method = resolveMethod(pjp); RedisLockAnnotation annotation = method.getAnnotation(RedisLockAnnotation.class); RedisLockTypeEnum typeEnum = annotation.typeEnum(); Object[] params = pjp.getArgs(); String ukString = params[annotation.lockFiled()].toString(); // 省略很多参数校验和判空 String businessKey = typeEnum.getUniqueKey(ukString); String uniqueValue = UUID.randomUUID().toString(); // 加锁 Object result = null; try { boolean isSuccess = redisTemplate.opsForValue().setIfAbsent(businessKey, uniqueValue); if (!isSuccess) { throw new Exception(&quot;You can&#39;t do it，because another has get the lock =-=&quot;); } redisTemplate.expire(businessKey, annotation.lockTime(), TimeUnit.SECONDS); Thread currentThread = Thread.currentThread(); // 将本次 Task 信息加入「延时」队列中 holderList.add(new RedisLockDefinitionHolder(businessKey, annotation.lockTime(), System.currentTimeMillis(), currentThread, annotation.tryCount())); // 执行业务操作 result = pjp.proceed(); // 线程被中断，抛出异常，中断此次请求 if (currentThread.isInterrupted()) { throw new InterruptedException(&quot;You had been interrupted =-=&quot;); } } catch (InterruptedException e ) { log.error(&quot;Interrupt exception, rollback transaction&quot;, e); throw new Exception(&quot;Interrupt exception, please send request again&quot;); } catch (Exception e) { log.error(&quot;has some error, please check again&quot;, e); } finally { // 请求结束后，强制删掉 key，释放锁 redisTemplate.delete(businessKey); log.info(&quot;release the lock, businessKey is [&quot; + businessKey + &quot;]&quot;); } return result; }上述流程简单总结一下： 解析注解参数，获取注解值和方法上的参数值 redis 加锁并且设置超时时间 将本次 Task 信息加入「延时」队列中，进行续时，方式提前释放锁 加了一个线程中断标志 结束请求，finally 中释放锁 续时操作这里用了 ScheduledExecutorService，维护了一个线程，不断对任务队列中的任务进行判断和延长超时时间： // 扫描的任务队列 private static ConcurrentLinkedQueue&lt;RedisLockDefinitionHolder&gt; holderList = new ConcurrentLinkedQueue(); /** * 线程池，维护keyAliveTime */ private static final ScheduledExecutorService SCHEDULER = new ScheduledThreadPoolExecutor(1, new BasicThreadFactory.Builder().namingPattern(&quot;redisLock-schedule-pool&quot;).daemon(true).build()); { // 两秒执行一次「续时」操作 SCHEDULER.scheduleAtFixedRate(() -&gt; { // 这里记得加 try-catch，否者报错后定时任务将不会再执行=-= Iterator&lt;RedisLockDefinitionHolder&gt; iterator = holderList.iterator(); while (iterator.hasNext()) { RedisLockDefinitionHolder holder = iterator.next(); // 判空 if (holder == null) { iterator.remove(); continue; } // 判断 key 是否还有效，无效的话进行移除 if (redisTemplate.opsForValue().get(holder.getBusinessKey()) == null) { iterator.remove(); continue; } // 超时重试次数，超过时给线程设定中断 if (holder.getCurrentCount() &gt; holder.getTryCount()) { holder.getCurrentTread().interrupt(); iterator.remove(); continue; } // 判断是否进入最后三分之一时间 long curTime = System.currentTimeMillis(); boolean shouldExtend = (holder.getLastModifyTime() + holder.getModifyPeriod()) &lt;= curTime; if (shouldExtend) { holder.setLastModifyTime(curTime); redisTemplate.expire(holder.getBusinessKey(), holder.getLockTime(), TimeUnit.SECONDS); log.info(&quot;businessKey : [&quot; + holder.getBusinessKey() + &quot;], try count : &quot; + holder.getCurrentCount()); holder.setCurrentCount(holder.getCurrentCount() + 1); } } }, 0, 2, TimeUnit.SECONDS); }这段代码，用来实现设计图中虚线框的思想，避免一个请求十分耗时，导致提前释放了锁。 这里加了「线程中断」Thread#interrupt，希望超过重试次数后，能让线程中断（未经严谨测试，仅供参考哈哈哈哈） 不过建议如果遇到这么耗时的请求，还是能够从根源上查找，分析耗时路径，进行业务优化或其它处理，避免这些耗时操作。 所以记得多打点 Log，分析问题时可以更快一点。如何使用SpringBoot AOP 记录操作日志、异常日志？ 五、开始测试在一个入口方法中，使用该注解，然后在业务中模拟耗时请求，使用了 Thread#sleep @GetMapping(&quot;/testRedisLock&quot;) @RedisLockAnnotation(typeEnum = RedisLockTypeEnum.ONE, lockTime = 3) public Book testRedisLock(@RequestParam(&quot;userId&quot;) Long userId) { try { log.info(&quot;睡眠执行前&quot;); Thread.sleep(10000); log.info(&quot;睡眠执行后&quot;); } catch (Exception e) { // log error log.info(&quot;has some error&quot;, e); } return null; }使用时，在方法上添加该注解，然后设定相应参数即可，根据 typeEnum 可以区分多种业务，限制该业务被同时操作。 测试结果： 2021-01-04 14:55:50.864 INFO 9326 --- [nio-8081-exec-1] c.s.demo.controller.BookController : 睡眠执行前 2021-01-04 14:55:52.855 INFO 9326 --- [k-schedule-pool] c.s.demo.aop.lock.RedisLockAspect : businessKey : [Business1:1024], try count : 0 2021-01-04 14:55:54.851 INFO 9326 --- [k-schedule-pool] c.s.demo.aop.lock.RedisLockAspect : businessKey : [Business1:1024], try count : 1 2021-01-04 14:55:56.851 INFO 9326 --- [k-schedule-pool] c.s.demo.aop.lock.RedisLockAspect : businessKey : [Business1:1024], try count : 2 2021-01-04 14:55:58.852 INFO 9326 --- [k-schedule-pool] c.s.demo.aop.lock.RedisLockAspect : businessKey : [Business1:1024], try count : 3 2021-01-04 14:56:00.857 INFO 9326 --- [nio-8081-exec-1] c.s.demo.controller.BookController : has some error java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) [na:1.8.0_221]我这里测试的是重试次数过多，失败的场景，如果减少睡眠时间，就能让业务正常执行。 如果同时请求，你将会发现以下错误信息： 2021-01-04 14:58:00.857 INFO 9326 --- [nio-8081-exec-9] c.s.demo.aop.lock.RedisLockAspect : has some error,please check again java.lang.Exception: You can&#39;t do it,because another has get the lock =-=表示我们的锁🔐的确生效了，避免了重复请求。 六、总结对于耗时业务和核心数据，不能让重复的请求同时操作数据，避免数据的不正确，所以要使用分布式锁来对它们进行保护。 再来梳理一下设计流程： 新建注解 @interface，在注解里设定入参标志 增加 AOP 切点，扫描特定注解 建立 @Aspect 切面任务，注册 bean 和拦截特定方法 特定方法参数 ProceedingJoinPoint，对方法 pjp.proceed() 前后进行拦截 切点前进行加锁，任务执行后进行删除 key 本次学习是通过 测试小姐姐 对操作进行并发测试，从中引申出分布式锁的概念和具体实现，然后写了一份简化版的业务处理。对于之前没考虑到的「续时」操作，这里使用了守护线程来定时判断和延长超时时间，避免了锁提前释放。 于是乎，同时回顾了三个知识点： 1、AOP 的实现和常用方法 2、定时线程池 ScheduledExecutorService 的使用和参数含义 3、线程 Thread#interrupt 的含义以及用法（这个挺有意思的，可以深入再学习一下） 具体代码放在了之前学习 SpringBoot 的项目中，感兴趣的可以克隆一下，使用这个 Redis 🔐","categories":[{"name":"并发操作","slug":"并发操作","permalink":"http://he49816306.github.io/categories/%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://he49816306.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"优化","slug":"优化","permalink":"http://he49816306.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"并发","slug":"并发","permalink":"http://he49816306.github.io/tags/%E5%B9%B6%E5%8F%91/"}]},{"title":"FutureTask源码","slug":"FutureTask源码","date":"2020-06-19T07:17:46.000Z","updated":"2020-06-19T07:24:36.885Z","comments":true,"path":"2020/06/19/FutureTask源码/","link":"","permalink":"http://he49816306.github.io/2020/06/19/FutureTask%E6%BA%90%E7%A0%81/","excerpt":"","text":"FutureTask源码简介实现了Future、Runnable接口，可以看成一个带执行结果的线程任务；代码很简单，就不说太多了，有些基础请私下问我，或者找度娘 成员变量 private volatile int state; private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; private Callable&lt;V&gt; callable; private Object outcome; private volatile Thread runner; private volatile WaitNode waiters; private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe(); private static final long STATE; private static final long RUNNER; private static final long WAITERS; static { try { STATE = U.objectFieldOffset (FutureTask.class.getDeclaredField(&quot;state&quot;)); RUNNER = U.objectFieldOffset (FutureTask.class.getDeclaredField(&quot;runner&quot;)); WAITERS = U.objectFieldOffset (FutureTask.class.getDeclaredField(&quot;waiters&quot;)); } catch (ReflectiveOperationException e) { throw new Error(e); } Class&lt;?&gt; ensureLoaded = LockSupport.class; }关键信息解读 state，waiters， runner都可以做原子操作（Unsafe类） state 有7种状态，0 可执行态，1是执行完毕态，2是可以获取结果状态，3是执行出现异常，4,5是未执行取消状态，6是执行过程中取消状态 callable 具体执行动作 outcome 执行结果 runner 动作执行所在线程 waiters 单向链表，表头，内部含有线程信息；表示获取结果的挂起线程队列 成员方法构造方法可以执行callble或者runnable对象，runnable对象使用适配器的方式，是配成新的callble对象，并且传入的result为结果；并确定当前状态为new，可执行状态 public FutureTask(Callable&lt;V&gt; callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; } public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; }report方法如果正常执行完毕，则返回执行结果，否则，根据状态抛出异常 private V report(int s) throws ExecutionException { Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x); }状态判断根据state对状态进行判断 public boolean isCancelled() { return state &gt;= CANCELLED; } public boolean isDone() { return state != NEW; }cancel任务用户主动取消任务，根据用户是否可打断、任务是否执行，来改变状态 4,5,6 public boolean cancel(boolean mayInterruptIfRunning) { if (!(state == NEW &amp;&amp; U.compareAndSwapInt(this, STATE, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try { // in case call to interrupt throws exception if (mayInterruptIfRunning) { try { Thread t = runner; if (t != null) t.interrupt(); } finally { // final state U.putOrderedInt(this, STATE, INTERRUPTED); } } } finally { finishCompletion(); } return true; }get获取执行结果获取任务执行结果，最多等待时间模式，和无线等待时间模式 public V get() throws InterruptedException, ExecutionException { int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); } /** * @throws CancellationException {@inheritDoc} */ public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { if (unit == null) throw new NullPointerException(); int s = state; if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING) throw new TimeoutException(); return report(s); }set执行结果设置执行结果，如果是执行时出现异常，则结果为异常对象，否则执行结果为正常运算结果；并进行状态置换，1是一个临时态，2,3是最终结果态 protected void set(V v) { if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) { outcome = v; U.putOrderedInt(this, STATE, NORMAL); finishCompletion(); } } protected void setException(Throwable t) { if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) { outcome = t; U.putOrderedInt(this, STATE, EXCEPTIONAL); finishCompletion(); } }任务执行项具体执行任务动作，run执行返回结果，runAndReset执行不带结果，可再次执行 public void run() { if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return; try { Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) { V result; boolean ran; try { result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } if (ran) set(result); } } finally { runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } protected boolean runAndReset() { if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return false; boolean ran = false; int s = state; try { Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; s == NEW) { try { c.call(); // don&#39;t set result ran = true; } catch (Throwable ex) { setException(ex); } } } finally { runner = null; s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); } return ran &amp;&amp; s == NEW; } 检查状态是否是可执行，并cas设置线程对象从null到当前线程 进行callable对象执行，如果出现异常，则设置异常结果，正常执行，返回正常结果 最终设置线程为空，如果状态执行时状态发生了变化，处理可能的取消打断操作 finishCompletion方法结束任务方法，执行结束，打断结束，取消结束 waiters节点置空，并且清除队列，并且唤醒每个非空线程节点，callable对象置空；done方法可被继承，本类中什么都不做 private void finishCompletion() { for (WaitNode q; (q = waiters) != null;) { if (U.compareAndSwapObject(this, WAITERS, q, null)) { for (;;) { Thread t = q.thread; if (t != null) { q.thread = null; LockSupport.unpark(t); } WaitNode next = q.next; if (next == null) break; q.next = null; q = next; } break; } } done(); callable = null; }awaitDone方法等待获取执行结果方法，传入参数有两种，（false， 0） （true，大于0的整数值）；自旋处理 private int awaitDone(boolean timed, long nanos) throws InterruptedException { long startTime = 0L; WaitNode q = null; boolean queued = false; for (;;) { int s = state; if (s &gt; COMPLETING) { if (q != null) q.thread = null; return s; } else if (s == COMPLETING) Thread.yield(); else if (Thread.interrupted()) { removeWaiter(q); throw new InterruptedException(); } else if (q == null) { if (timed &amp;&amp; nanos &lt;= 0L) return s; q = new WaitNode(); } else if (!queued) queued = U.compareAndSwapObject(this, WAITERS,q.next = waiters, q); else if (timed) { final long parkNanos; if (startTime == 0L) { startTime = System.nanoTime(); if (startTime == 0L) startTime = 1L; parkNanos = nanos; } else { long elapsed = System.nanoTime() - startTime; if (elapsed &gt;= nanos) { removeWaiter(q); return state; } parkNanos = nanos - elapsed; } if (state &lt; COMPLETING) LockSupport.parkNanos(this, parkNanos); } else LockSupport.park(this); } } 自旋过程按照下面书序来执行 状态判断，有3中状态判断：已有结果态，马上有结果态，获取结果被打断状态 状态大于1，不是有结果了，就是异常了，就是被主动取消了，这时直接返回结果；状态等于1表示马上就到2或者3状态，下个循环就是状态大于1，直接返回结果 如果线程正在执行，且被打断，重置打断状态，并且异常当前线程节点，抛出打断异常 新建当前线程获取结果排队节点 加入获取结果队列中，并且置为waiters，之前waiters值为next指向节点 进行获取，有限时间内获取，或者无限制时间获取 如果有限时间内获取，如果超时，返回当前状态，如果未超时且当前状态在正在执行状态，则线程挂起计算时间 不限制时间获取，则直接等待 removeWaiter方法自旋处理，删除节点线程属性为空的节点 private void removeWaiter(WaitNode node) { if (node != null) { node.thread = null; retry: for (;;) { // restart on removeWaiter race for (WaitNode pred = null, q = waiters, s; q != null; q = s) { s = q.next; if (q.thread != null) pred = q; else if (pred != null) { pred.next = s; if (pred.thread == null) continue retry; } else if (!U.compareAndSwapObject(this, WAITERS, q, s)) continue retry; } break; } } }处理思路： 如果当前第一个节点的线程为空，则把下个线程置为头节点，如果还空继续此过程，知道头节点线程不为空，这是pred指向头，q为头下个节点，s为q下个节点 如果q的线程为空，则把pred的next指向s 如果q的线程不为空，则继续移动这3个节点对象，直到q为空，退出自旋 源码总结： 获取结果为阻塞过程，会挂起线程；等待结果执行完毕会被全部唤醒 线程排队队列为单向链表，有指向下个节点属性；每次插入链表头部 执行过程，进行结果处理，和唤醒链表中节点线程 执行一次带结果动作，或者重复执行不带结果动作","categories":[{"name":"技术原理","slug":"技术原理","permalink":"http://he49816306.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"原理","slug":"原理","permalink":"http://he49816306.github.io/tags/%E5%8E%9F%E7%90%86/"},{"name":"源码","slug":"源码","permalink":"http://he49816306.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"多线程","slug":"多线程","permalink":"http://he49816306.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"大话CY的那些日子","slug":"大话CY的那些日子","date":"2020-06-19T06:21:47.000Z","updated":"2021-01-07T08:21:57.078Z","comments":true,"path":"2020/06/19/大话CY的那些日子/","link":"","permalink":"http://he49816306.github.io/2020/06/19/%E5%A4%A7%E8%AF%9DCY%E7%9A%84%E9%82%A3%E4%BA%9B%E6%97%A5%E5%AD%90/","excerpt":"","text":"谈谈CY的日子其实还是很开心的拉。只是现在看到阿喵更开心~~ PS：不过阿喵 虽然被鸡哥哥坑掉了，但是后面还是去了hz，开发了云平台，还是很不错滴拉。！","categories":[{"name":"生活日常","slug":"生活日常","permalink":"http://he49816306.github.io/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"http://he49816306.github.io/tags/%E9%97%B2%E8%81%8A/"}]},{"title":"十大经典排序算法整理汇总（附代码）","slug":"sort-algorithms","date":"2020-02-16T07:09:23.000Z","updated":"2020-06-18T09:13:57.998Z","comments":true,"path":"2020/02/16/sort-algorithms/","link":"","permalink":"http://he49816306.github.io/2020/02/16/sort-algorithms/","excerpt":"","text":"经常即将开始！！！ 前言本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。 本文并不会详细讲解每种排序算法的原理，网上有很多很好的教程，大家可以自己去搜了看。 最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 LeetCode 912. 排序数组 这道题。 性质汇总 如果发现表中有错误，请留言告知。 算法 最好 最坏 平均 空间 稳定性 是否基于比较 冒泡排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ $\\checkmark$ $\\checkmark$ 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ $\\times$ $\\checkmark$ 插入排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ $\\checkmark$ $\\checkmark$ 快速排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(\\log n)$~$O(n)$ $\\times$ $\\checkmark$ 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(n)$ $\\checkmark$ $\\checkmark$ 希尔排序 $O(n^{1.3})$ $O(n^2)$ $O(n\\log n)$~$O(n^2)$ $O(1)$ $\\times$ $\\checkmark$ 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(n+k)$ $\\checkmark$ $\\times$ 基数排序 $O(nk)$ $O(nk)$ $O(nk)$ $O(n+k)$ $\\checkmark$ $\\times$ 桶排序 $O(n)$ $O(n)$ $O(n)$ $O(n+m)$ $\\checkmark$ $\\times$ 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(1)$ $\\times$ $\\checkmark$ 如果表格显示有问题的话，还可以直接看下面的汇总图： 维基百科我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。 冒泡排序https://en.wikipedia.org/wiki/Bubble_sort 选择排序https://en.wikipedia.org/wiki/Selection_sort 插入排序https://en.wikipedia.org/wiki/Insertion_sort 快速排序https://en.wikipedia.org/wiki/Quicksort 归并排序https://en.wikipedia.org/wiki/Merge_sort 希尔排序https://en.wikipedia.org/wiki/Shellsort 计数排序https://en.wikipedia.org/wiki/Counting_sort 基数排序https://en.wikipedia.org/wiki/Radix_sort 桶排序https://en.wikipedia.org/wiki/Bucket_sort 堆排序https://en.wikipedia.org/wiki/Heapsort 代码实现所有的排序算法接口都是相同的，也就是 vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums) 。只需要你传入一个 vector&lt;int&gt; 类型的数组，就能返回排序后的结果。 运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。 class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { return quickSort(nums); } // 冒泡排序（超时） vector&lt;int&gt; bubbleSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { for (int j = n-2; j &gt;= i; --j) { if (nums[j] &gt; nums[j+1]) { swap(nums[j], nums[j+1]); } } } return nums; } // 选择排序（超时） vector&lt;int&gt; selectSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { int idx = i; for (int j = i; j &lt; n; ++j) { if (nums[j] &lt; nums[idx]) { idx = j; } } swap(nums[i], nums[idx]); } return nums; } // 插入排序（超时） vector&lt;int&gt; insertSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; --j) { swap(nums[j], nums[j-1]); } } return nums; } // 快速排序（24 ms） void qSort(vector&lt;int&gt;&amp; nums, int l, int r) { if (l &gt;= r) return; int m = l; for (int i = l; i &lt; r; ++i) { if (nums[i] &lt; nums[r]) { swap(nums[m++], nums[i]); } } swap(nums[m], nums[r]); qSort(nums, l, m-1); qSort(nums, m+1, r); } vector&lt;int&gt; quickSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); qSort(nums, 0, n-1); return nums; } // 归并排序（192 ms） vector&lt;int&gt; mSort(vector&lt;int&gt;&amp; nums, int l, int r) { if (l &gt;= r) return {nums[l]}; int m = l+(r-l)/2; vector&lt;int&gt; lnums = mSort(nums, l, m); vector&lt;int&gt; rnums = mSort(nums, m+1, r); vector&lt;int&gt; res; int i = 0, j = 0; while (i &lt;= m-l &amp;&amp; j &lt;= r-m-1) { if (lnums[i] &lt; rnums[j]) { res.push_back(lnums[i++]); } else { res.push_back(rnums[j++]); } } while (i &lt;= m-l) { res.push_back(lnums[i++]); } while (j &lt;= r-m-1) { res.push_back(rnums[j++]); } return res; } vector&lt;int&gt; mergeSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); nums = mSort(nums, 0, n-1); return nums; } // 归并排序 + 非递归（80 ms） vector&lt;int&gt; mergeSortNR(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int len = 1; len &lt; n; len &lt;&lt;= 1) { for (int l = 0; l &lt; n-len; l += 2*len) { int m = l+len-1; int r = min(n-1, l+2*len-1); vector&lt;int&gt; res; int i = l, j = m+1; while (i &lt;= m &amp;&amp; j &lt;= r) { if (nums[i] &lt; nums[j]) { res.push_back(nums[i++]); } else { res.push_back(nums[j++]); } } while (i &lt;= m) { res.push_back(nums[i++]); } while (j &lt;= r) { res.push_back(nums[j++]); } for (int i = l; i &lt;= r; ++i) { nums[i] = res[i-l]; } } } return nums; } // 希尔排序（40 ms） vector&lt;int&gt; shellSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int gap = n/2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; n; ++i) { for (int j = i; j-gap &gt;= 0 &amp;&amp; nums[j-gap] &gt; nums[j]; j -= gap) { swap(nums[j-gap], nums[j]); } } } return nums; } // 计数排序（32 ms） vector&lt;int&gt; countSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (!n) return {}; int minv = *min_element(nums.begin(), nums.end()); int maxv = *max_element(nums.begin(), nums.end()); int m = maxv-minv+1; vector&lt;int&gt; count(m, 0); for (int i = 0; i &lt; n; ++i) { count[nums[i]-minv]++; } vector&lt;int&gt; res; for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; count[i]; ++j) { res.push_back(i+minv); } } return res; } // 基数排序（不适用于负数） vector&lt;int&gt; radixSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int maxv = *max_element(nums.begin(), nums.end()); int maxd = 0; while (maxv &gt; 0) { maxv /= 10; maxd++; } vector&lt;int&gt; count(10, 0), rank(n, 0); int base = 1; while (maxd &gt; 0) { count.assign(10, 0); for (int i = 0; i &lt; n; ++i) { count[(nums[i]/base)%10]++; } for (int i = 1; i &lt; 10; ++i) { count[i] += count[i-1]; } for (int i = n-1; i &gt;= 0; --i) { rank[--count[(nums[i]/base)%10]] = nums[i]; } for (int i = 0; i &lt; n; ++i) { nums[i] = rank[i]; } maxd--; base *= 10; } return nums; } // 桶排序 (20 ms) vector&lt;int&gt; bucketSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int maxv = *max_element(nums.begin(), nums.end()); int minv = *min_element(nums.begin(), nums.end()); int bs = 1000; int m = (maxv-minv)/bs+1; vector&lt;vector&lt;int&gt; &gt; bucket(m); for (int i = 0; i &lt; n; ++i) { bucket[(nums[i]-minv)/bs].push_back(nums[i]); } int idx = 0; for (int i = 0; i &lt; m; ++i) { int sz = bucket[i].size(); bucket[i] = quickSort(bucket[i]); for (int j = 0; j &lt; sz; ++j) { nums[idx++] = bucket[i][j]; } } return nums; } // 堆排序（32 ms） void adjust(vector&lt;int&gt;&amp; nums, int p, int s) { while (2*p+1 &lt; s) { int c1 = 2*p+1; int c2 = 2*p+2; int c = (c2&lt;s &amp;&amp; nums[c2]&gt;nums[c1]) ? c2 : c1; if (nums[c] &gt; nums[p]) swap(nums[c], nums[p]); else break; p = c; } } vector&lt;int&gt; heapSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = n/2-1; i &gt;= 0; --i) { adjust(nums, i, n); } for (int i = n-1; i &gt; 0; --i) { swap(nums[0], nums[i]); adjust(nums, 0, i); } return nums; } };","categories":[{"name":"编程算法","slug":"编程算法","permalink":"http://he49816306.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://he49816306.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://he49816306.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-15T07:09:23.000Z","updated":"2021-01-07T06:23:35.591Z","comments":true,"path":"2020/02/15/hello-world/","link":"","permalink":"http://he49816306.github.io/2020/02/15/hello-world/","excerpt":"","text":"Welcome to blog! This is your very first post. Check documentation for more info. If you get any problems when using blog, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"编程算法","slug":"编程算法","permalink":"http://he49816306.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://he49816306.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://he49816306.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"并发操作","slug":"并发操作","permalink":"http://he49816306.github.io/categories/%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/"},{"name":"技术原理","slug":"技术原理","permalink":"http://he49816306.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"},{"name":"生活日常","slug":"生活日常","permalink":"http://he49816306.github.io/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"},{"name":"编程算法","slug":"编程算法","permalink":"http://he49816306.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://he49816306.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"优化","slug":"优化","permalink":"http://he49816306.github.io/tags/%E4%BC%98%E5%8C%96/"},{"name":"并发","slug":"并发","permalink":"http://he49816306.github.io/tags/%E5%B9%B6%E5%8F%91/"},{"name":"原理","slug":"原理","permalink":"http://he49816306.github.io/tags/%E5%8E%9F%E7%90%86/"},{"name":"源码","slug":"源码","permalink":"http://he49816306.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"闲聊","slug":"闲聊","permalink":"http://he49816306.github.io/tags/%E9%97%B2%E8%81%8A/"},{"name":"leetcode","slug":"leetcode","permalink":"http://he49816306.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://he49816306.github.io/tags/%E7%AE%97%E6%B3%95/"}]}