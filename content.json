{"meta":{"title":"Malroy的博客","subtitle":"会当凌绝顶","description":"重庆大学 | 计算机科学与技术 | 自然语言处理","author":"Malroy","url":"http://he49816306.github.io","root":"/"},"pages":[{"title":"404","date":"2019-07-19T08:41:10.000Z","updated":"2020-06-17T09:38:04.362Z","comments":true,"path":"404.html","permalink":"http://he49816306.github.io/404.html","excerpt":"","text":""},{"title":"about","date":"2019-07-19T08:41:10.000Z","updated":"2020-06-18T09:16:05.966Z","comments":true,"path":"about/index.html","permalink":"http://he49816306.github.io/about/index.html","excerpt":"","text":"教育经历 硕士 计算机科学与技术重庆大学2019/06 - 现在 本科 计算机科学与技术重庆大学2015/09 - 2019/06综合排名专业第一 获得荣誉2017 金牌ACM-ICPC全国邀请赛（陕西） 特等奖学金大三学年 二等奖蓝桥杯C++组（上海） 团体一等奖中国高校计算机大赛-团体程序设计天梯赛 高校一等奖中国高校计算机大赛-团体程序设计天梯赛 2016 银牌ACM-ICPC亚洲区域赛（青岛） 铜牌ACM-CCPC总决赛（宁波） 铜牌ACM-CCPC（杭州） 一等奖学金大二学年 2015 国家奖学金大一学年 铜牌ACM-ICPC亚洲区域赛（上海） 铜牌ACM-ICPC上海大都会赛 联系方式 电子邮箱62614929@qq.com 地址重庆虎溪 QQ 技术交流群520520520"},{"title":"archives","date":"2019-07-19T08:39:20.000Z","updated":"2020-06-17T09:38:04.364Z","comments":true,"path":"archives/index.html","permalink":"http://he49816306.github.io/archives/index.html","excerpt":"","text":""},{"title":"contact","date":"2019-07-26T09:17:02.000Z","updated":"2020-06-18T09:16:51.437Z","comments":true,"path":"contact/index.html","permalink":"http://he49816306.github.io/contact/index.html","excerpt":"","text":"欢迎留言大家有任何问题，都可以在评论区给我留言，或者加 QQ 技术交流群【群号：520520520】。 我很忙啦，如果不是很麻烦的问题就直接在评论区留言啦。 友链交换想要交换友链的小伙伴，欢迎在评论区留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址"},{"title":"categories","date":"2019-07-19T08:39:20.000Z","updated":"2020-06-17T09:38:04.365Z","comments":true,"path":"categories/index.html","permalink":"http://he49816306.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-19T08:42:10.000Z","updated":"2020-06-18T09:17:06.050Z","comments":true,"path":"friends/index.html","permalink":"http://he49816306.github.io/friends/index.html","excerpt":"","text":"友链交换想要交换友链的小伙伴，欢迎在留言板留言，留言格式： 名称：你的博客名称 地址：你的博客地址 简介：一句话简介 头像：你的头像地址"},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2020-06-17T09:38:04.366Z","comments":true,"path":"tags/index.html","permalink":"http://he49816306.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-06-23T09:05:25.698Z","updated":"2020-06-18T09:48:02.734Z","comments":true,"path":"2020/06/23/hello-world/","link":"","permalink":"http://he49816306.github.io/2020/06/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"编程算法","slug":"编程算法","permalink":"http://he49816306.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://he49816306.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://he49816306.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"FutureTask源码","slug":"FutureTask源码","date":"2020-06-19T07:17:46.000Z","updated":"2020-06-19T07:24:36.885Z","comments":true,"path":"2020/06/19/FutureTask源码/","link":"","permalink":"http://he49816306.github.io/2020/06/19/FutureTask%E6%BA%90%E7%A0%81/","excerpt":"","text":"FutureTask源码简介实现了Future、Runnable接口，可以看成一个带执行结果的线程任务；代码很简单，就不说太多了，有些基础请私下问我，或者找度娘 成员变量 private volatile int state; private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; private Callable&lt;V&gt; callable; private Object outcome; private volatile Thread runner; private volatile WaitNode waiters; private static final sun.misc.Unsafe U = sun.misc.Unsafe.getUnsafe(); private static final long STATE; private static final long RUNNER; private static final long WAITERS; static { try { STATE = U.objectFieldOffset (FutureTask.class.getDeclaredField(&quot;state&quot;)); RUNNER = U.objectFieldOffset (FutureTask.class.getDeclaredField(&quot;runner&quot;)); WAITERS = U.objectFieldOffset (FutureTask.class.getDeclaredField(&quot;waiters&quot;)); } catch (ReflectiveOperationException e) { throw new Error(e); } Class&lt;?&gt; ensureLoaded = LockSupport.class; }关键信息解读 state，waiters， runner都可以做原子操作（Unsafe类） state 有7种状态，0 可执行态，1是执行完毕态，2是可以获取结果状态，3是执行出现异常，4,5是未执行取消状态，6是执行过程中取消状态 callable 具体执行动作 outcome 执行结果 runner 动作执行所在线程 waiters 单向链表，表头，内部含有线程信息；表示获取结果的挂起线程队列 成员方法构造方法可以执行callble或者runnable对象，runnable对象使用适配器的方式，是配成新的callble对象，并且传入的result为结果；并确定当前状态为new，可执行状态 public FutureTask(Callable&lt;V&gt; callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; } public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; }report方法如果正常执行完毕，则返回执行结果，否则，根据状态抛出异常 private V report(int s) throws ExecutionException { Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x); }状态判断根据state对状态进行判断 public boolean isCancelled() { return state &gt;= CANCELLED; } public boolean isDone() { return state != NEW; }cancel任务用户主动取消任务，根据用户是否可打断、任务是否执行，来改变状态 4,5,6 public boolean cancel(boolean mayInterruptIfRunning) { if (!(state == NEW &amp;&amp; U.compareAndSwapInt(this, STATE, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try { // in case call to interrupt throws exception if (mayInterruptIfRunning) { try { Thread t = runner; if (t != null) t.interrupt(); } finally { // final state U.putOrderedInt(this, STATE, INTERRUPTED); } } } finally { finishCompletion(); } return true; }get获取执行结果获取任务执行结果，最多等待时间模式，和无线等待时间模式 public V get() throws InterruptedException, ExecutionException { int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); } /** * @throws CancellationException {@inheritDoc} */ public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException { if (unit == null) throw new NullPointerException(); int s = state; if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING) throw new TimeoutException(); return report(s); }set执行结果设置执行结果，如果是执行时出现异常，则结果为异常对象，否则执行结果为正常运算结果；并进行状态置换，1是一个临时态，2,3是最终结果态 protected void set(V v) { if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) { outcome = v; U.putOrderedInt(this, STATE, NORMAL); finishCompletion(); } } protected void setException(Throwable t) { if (U.compareAndSwapInt(this, STATE, NEW, COMPLETING)) { outcome = t; U.putOrderedInt(this, STATE, EXCEPTIONAL); finishCompletion(); } }任务执行项具体执行任务动作，run执行返回结果，runAndReset执行不带结果，可再次执行 public void run() { if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return; try { Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) { V result; boolean ran; try { result = c.call(); ran = true; } catch (Throwable ex) { result = null; ran = false; setException(ex); } if (ran) set(result); } } finally { runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); } } protected boolean runAndReset() { if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return false; boolean ran = false; int s = state; try { Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; s == NEW) { try { c.call(); // don&#39;t set result ran = true; } catch (Throwable ex) { setException(ex); } } } finally { runner = null; s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); } return ran &amp;&amp; s == NEW; } 检查状态是否是可执行，并cas设置线程对象从null到当前线程 进行callable对象执行，如果出现异常，则设置异常结果，正常执行，返回正常结果 最终设置线程为空，如果状态执行时状态发生了变化，处理可能的取消打断操作 finishCompletion方法结束任务方法，执行结束，打断结束，取消结束 waiters节点置空，并且清除队列，并且唤醒每个非空线程节点，callable对象置空；done方法可被继承，本类中什么都不做 private void finishCompletion() { for (WaitNode q; (q = waiters) != null;) { if (U.compareAndSwapObject(this, WAITERS, q, null)) { for (;;) { Thread t = q.thread; if (t != null) { q.thread = null; LockSupport.unpark(t); } WaitNode next = q.next; if (next == null) break; q.next = null; q = next; } break; } } done(); callable = null; }awaitDone方法等待获取执行结果方法，传入参数有两种，（false， 0） （true，大于0的整数值）；自旋处理 private int awaitDone(boolean timed, long nanos) throws InterruptedException { long startTime = 0L; WaitNode q = null; boolean queued = false; for (;;) { int s = state; if (s &gt; COMPLETING) { if (q != null) q.thread = null; return s; } else if (s == COMPLETING) Thread.yield(); else if (Thread.interrupted()) { removeWaiter(q); throw new InterruptedException(); } else if (q == null) { if (timed &amp;&amp; nanos &lt;= 0L) return s; q = new WaitNode(); } else if (!queued) queued = U.compareAndSwapObject(this, WAITERS,q.next = waiters, q); else if (timed) { final long parkNanos; if (startTime == 0L) { startTime = System.nanoTime(); if (startTime == 0L) startTime = 1L; parkNanos = nanos; } else { long elapsed = System.nanoTime() - startTime; if (elapsed &gt;= nanos) { removeWaiter(q); return state; } parkNanos = nanos - elapsed; } if (state &lt; COMPLETING) LockSupport.parkNanos(this, parkNanos); } else LockSupport.park(this); } } 自旋过程按照下面书序来执行 状态判断，有3中状态判断：已有结果态，马上有结果态，获取结果被打断状态 状态大于1，不是有结果了，就是异常了，就是被主动取消了，这时直接返回结果；状态等于1表示马上就到2或者3状态，下个循环就是状态大于1，直接返回结果 如果线程正在执行，且被打断，重置打断状态，并且异常当前线程节点，抛出打断异常 新建当前线程获取结果排队节点 加入获取结果队列中，并且置为waiters，之前waiters值为next指向节点 进行获取，有限时间内获取，或者无限制时间获取 如果有限时间内获取，如果超时，返回当前状态，如果未超时且当前状态在正在执行状态，则线程挂起计算时间 不限制时间获取，则直接等待 removeWaiter方法自旋处理，删除节点线程属性为空的节点 private void removeWaiter(WaitNode node) { if (node != null) { node.thread = null; retry: for (;;) { // restart on removeWaiter race for (WaitNode pred = null, q = waiters, s; q != null; q = s) { s = q.next; if (q.thread != null) pred = q; else if (pred != null) { pred.next = s; if (pred.thread == null) continue retry; } else if (!U.compareAndSwapObject(this, WAITERS, q, s)) continue retry; } break; } } }处理思路： 如果当前第一个节点的线程为空，则把下个线程置为头节点，如果还空继续此过程，知道头节点线程不为空，这是pred指向头，q为头下个节点，s为q下个节点 如果q的线程为空，则把pred的next指向s 如果q的线程不为空，则继续移动这3个节点对象，直到q为空，退出自旋 源码总结： 获取结果为阻塞过程，会挂起线程；等待结果执行完毕会被全部唤醒 线程排队队列为单向链表，有指向下个节点属性；每次插入链表头部 执行过程，进行结果处理，和唤醒链表中节点线程 执行一次带结果动作，或者重复执行不带结果动作","categories":[{"name":"技术原理","slug":"技术原理","permalink":"http://he49816306.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"原理","slug":"原理","permalink":"http://he49816306.github.io/tags/%E5%8E%9F%E7%90%86/"},{"name":"源码","slug":"源码","permalink":"http://he49816306.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"多线程","slug":"多线程","permalink":"http://he49816306.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"大话CY的那些日子","slug":"大话CY的那些日子","date":"2020-06-19T06:21:47.000Z","updated":"2020-06-19T06:23:18.914Z","comments":true,"path":"2020/06/19/大话CY的那些日子/","link":"","permalink":"http://he49816306.github.io/2020/06/19/%E5%A4%A7%E8%AF%9DCY%E7%9A%84%E9%82%A3%E4%BA%9B%E6%97%A5%E5%AD%90/","excerpt":"","text":"谈谈CY的日子其实还是很开心的拉。只是现在看到阿喵更开心~~","categories":[{"name":"生活日常","slug":"生活日常","permalink":"http://he49816306.github.io/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"http://he49816306.github.io/tags/%E9%97%B2%E8%81%8A/"}]},{"title":"十大经典排序算法整理汇总（附代码）","slug":"sort-algorithms","date":"2020-02-16T07:09:23.000Z","updated":"2020-06-18T09:13:57.998Z","comments":true,"path":"2020/02/16/sort-algorithms/","link":"","permalink":"http://he49816306.github.io/2020/02/16/sort-algorithms/","excerpt":"","text":"经常即将开始！！！ 前言本文整理并总结了十大经典的排序算法（冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序、计数排序、基数排序、桶排序、堆排序）的时间复杂度、空间复杂度等性质。 本文并不会详细讲解每种排序算法的原理，网上有很多很好的教程，大家可以自己去搜了看。 最后我还亲自手写了十种排序算法的 c++ 代码，大家可以用来通过 LeetCode 912. 排序数组 这道题。 性质汇总 如果发现表中有错误，请留言告知。 算法 最好 最坏 平均 空间 稳定性 是否基于比较 冒泡排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ $\\checkmark$ $\\checkmark$ 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ $\\times$ $\\checkmark$ 插入排序 $O(n)$ $O(n^2)$ $O(n^2)$ $O(1)$ $\\checkmark$ $\\checkmark$ 快速排序 $O(n\\log n)$ $O(n^2)$ $O(n\\log n)$ $O(\\log n)$~$O(n)$ $\\times$ $\\checkmark$ 归并排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(n)$ $\\checkmark$ $\\checkmark$ 希尔排序 $O(n^{1.3})$ $O(n^2)$ $O(n\\log n)$~$O(n^2)$ $O(1)$ $\\times$ $\\checkmark$ 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(n+k)$ $\\checkmark$ $\\times$ 基数排序 $O(nk)$ $O(nk)$ $O(nk)$ $O(n+k)$ $\\checkmark$ $\\times$ 桶排序 $O(n)$ $O(n)$ $O(n)$ $O(n+m)$ $\\checkmark$ $\\times$ 堆排序 $O(n\\log n)$ $O(n\\log n)$ $O(n\\log n)$ $O(1)$ $\\times$ $\\checkmark$ 如果表格显示有问题的话，还可以直接看下面的汇总图： 维基百科我觉得还是英文维基百科讲的比较详细、严谨。如果大家看的比较累的话，可以自己百度搜索相应的教程。 冒泡排序https://en.wikipedia.org/wiki/Bubble_sort 选择排序https://en.wikipedia.org/wiki/Selection_sort 插入排序https://en.wikipedia.org/wiki/Insertion_sort 快速排序https://en.wikipedia.org/wiki/Quicksort 归并排序https://en.wikipedia.org/wiki/Merge_sort 希尔排序https://en.wikipedia.org/wiki/Shellsort 计数排序https://en.wikipedia.org/wiki/Counting_sort 基数排序https://en.wikipedia.org/wiki/Radix_sort 桶排序https://en.wikipedia.org/wiki/Bucket_sort 堆排序https://en.wikipedia.org/wiki/Heapsort 代码实现所有的排序算法接口都是相同的，也就是 vector&lt;int&gt; xxxSort(vector&lt;int&gt;&amp; nums) 。只需要你传入一个 vector&lt;int&gt; 类型的数组，就能返回排序后的结果。 运行下来可以发现，桶排序速度是比较快的。而冒泡排序、选择排序和插入排序因为时间复杂度太高无法通过本题，基数排序因为无法处理负数也不能通过本题。 class Solution { public: vector&lt;int&gt; sortArray(vector&lt;int&gt;&amp; nums) { return quickSort(nums); } // 冒泡排序（超时） vector&lt;int&gt; bubbleSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { for (int j = n-2; j &gt;= i; --j) { if (nums[j] &gt; nums[j+1]) { swap(nums[j], nums[j+1]); } } } return nums; } // 选择排序（超时） vector&lt;int&gt; selectSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { int idx = i; for (int j = i; j &lt; n; ++j) { if (nums[j] &lt; nums[idx]) { idx = j; } } swap(nums[i], nums[idx]); } return nums; } // 插入排序（超时） vector&lt;int&gt; insertSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = 0; i &lt; n; ++i) { for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; --j) { swap(nums[j], nums[j-1]); } } return nums; } // 快速排序（24 ms） void qSort(vector&lt;int&gt;&amp; nums, int l, int r) { if (l &gt;= r) return; int m = l; for (int i = l; i &lt; r; ++i) { if (nums[i] &lt; nums[r]) { swap(nums[m++], nums[i]); } } swap(nums[m], nums[r]); qSort(nums, l, m-1); qSort(nums, m+1, r); } vector&lt;int&gt; quickSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); qSort(nums, 0, n-1); return nums; } // 归并排序（192 ms） vector&lt;int&gt; mSort(vector&lt;int&gt;&amp; nums, int l, int r) { if (l &gt;= r) return {nums[l]}; int m = l+(r-l)/2; vector&lt;int&gt; lnums = mSort(nums, l, m); vector&lt;int&gt; rnums = mSort(nums, m+1, r); vector&lt;int&gt; res; int i = 0, j = 0; while (i &lt;= m-l &amp;&amp; j &lt;= r-m-1) { if (lnums[i] &lt; rnums[j]) { res.push_back(lnums[i++]); } else { res.push_back(rnums[j++]); } } while (i &lt;= m-l) { res.push_back(lnums[i++]); } while (j &lt;= r-m-1) { res.push_back(rnums[j++]); } return res; } vector&lt;int&gt; mergeSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); nums = mSort(nums, 0, n-1); return nums; } // 归并排序 + 非递归（80 ms） vector&lt;int&gt; mergeSortNR(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int len = 1; len &lt; n; len &lt;&lt;= 1) { for (int l = 0; l &lt; n-len; l += 2*len) { int m = l+len-1; int r = min(n-1, l+2*len-1); vector&lt;int&gt; res; int i = l, j = m+1; while (i &lt;= m &amp;&amp; j &lt;= r) { if (nums[i] &lt; nums[j]) { res.push_back(nums[i++]); } else { res.push_back(nums[j++]); } } while (i &lt;= m) { res.push_back(nums[i++]); } while (j &lt;= r) { res.push_back(nums[j++]); } for (int i = l; i &lt;= r; ++i) { nums[i] = res[i-l]; } } } return nums; } // 希尔排序（40 ms） vector&lt;int&gt; shellSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int gap = n/2; gap &gt; 0; gap /= 2) { for (int i = gap; i &lt; n; ++i) { for (int j = i; j-gap &gt;= 0 &amp;&amp; nums[j-gap] &gt; nums[j]; j -= gap) { swap(nums[j-gap], nums[j]); } } } return nums; } // 计数排序（32 ms） vector&lt;int&gt; countSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (!n) return {}; int minv = *min_element(nums.begin(), nums.end()); int maxv = *max_element(nums.begin(), nums.end()); int m = maxv-minv+1; vector&lt;int&gt; count(m, 0); for (int i = 0; i &lt; n; ++i) { count[nums[i]-minv]++; } vector&lt;int&gt; res; for (int i = 0; i &lt; m; ++i) { for (int j = 0; j &lt; count[i]; ++j) { res.push_back(i+minv); } } return res; } // 基数排序（不适用于负数） vector&lt;int&gt; radixSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int maxv = *max_element(nums.begin(), nums.end()); int maxd = 0; while (maxv &gt; 0) { maxv /= 10; maxd++; } vector&lt;int&gt; count(10, 0), rank(n, 0); int base = 1; while (maxd &gt; 0) { count.assign(10, 0); for (int i = 0; i &lt; n; ++i) { count[(nums[i]/base)%10]++; } for (int i = 1; i &lt; 10; ++i) { count[i] += count[i-1]; } for (int i = n-1; i &gt;= 0; --i) { rank[--count[(nums[i]/base)%10]] = nums[i]; } for (int i = 0; i &lt; n; ++i) { nums[i] = rank[i]; } maxd--; base *= 10; } return nums; } // 桶排序 (20 ms) vector&lt;int&gt; bucketSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); int maxv = *max_element(nums.begin(), nums.end()); int minv = *min_element(nums.begin(), nums.end()); int bs = 1000; int m = (maxv-minv)/bs+1; vector&lt;vector&lt;int&gt; &gt; bucket(m); for (int i = 0; i &lt; n; ++i) { bucket[(nums[i]-minv)/bs].push_back(nums[i]); } int idx = 0; for (int i = 0; i &lt; m; ++i) { int sz = bucket[i].size(); bucket[i] = quickSort(bucket[i]); for (int j = 0; j &lt; sz; ++j) { nums[idx++] = bucket[i][j]; } } return nums; } // 堆排序（32 ms） void adjust(vector&lt;int&gt;&amp; nums, int p, int s) { while (2*p+1 &lt; s) { int c1 = 2*p+1; int c2 = 2*p+2; int c = (c2&lt;s &amp;&amp; nums[c2]&gt;nums[c1]) ? c2 : c1; if (nums[c] &gt; nums[p]) swap(nums[c], nums[p]); else break; p = c; } } vector&lt;int&gt; heapSort(vector&lt;int&gt;&amp; nums) { int n = nums.size(); for (int i = n/2-1; i &gt;= 0; --i) { adjust(nums, i, n); } for (int i = n-1; i &gt; 0; --i) { swap(nums[0], nums[i]); adjust(nums, 0, i); } return nums; } };","categories":[{"name":"编程算法","slug":"编程算法","permalink":"http://he49816306.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://he49816306.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://he49816306.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"编程算法","slug":"编程算法","permalink":"http://he49816306.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"},{"name":"技术原理","slug":"技术原理","permalink":"http://he49816306.github.io/categories/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"},{"name":"生活日常","slug":"生活日常","permalink":"http://he49816306.github.io/categories/%E7%94%9F%E6%B4%BB%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://he49816306.github.io/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://he49816306.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"原理","slug":"原理","permalink":"http://he49816306.github.io/tags/%E5%8E%9F%E7%90%86/"},{"name":"源码","slug":"源码","permalink":"http://he49816306.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"多线程","slug":"多线程","permalink":"http://he49816306.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"闲聊","slug":"闲聊","permalink":"http://he49816306.github.io/tags/%E9%97%B2%E8%81%8A/"}]}